<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Image Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #111;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif;
      overflow: hidden;
    }
    #toolbar {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      border-radius: 10px;
      padding: 6px 10px;
      z-index: 10;
      display: flex;
      gap: 8px;
      backdrop-filter: blur(6px);
    }
    #toolbar button {
      border: none;
      padding: 6px 12px;
      border-radius: 8px;
      background: #444;
      color: #fff;
      cursor: pointer;
    }
    #toolbar button:hover { background: #666; }

    #viewer {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      cursor: grab;
      user-select: none;
    }

    /* Ключевое: якорим трансформации к левому верхнему углу */
    #image {
      transform-origin: 0 0;
      user-select: none;
      -webkit-user-drag: none;
      max-width: none; /* важно: не даём браузеру масштабировать автоматически */
      will-change: transform;
    }

    #hint {
      position: fixed;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.55);
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      opacity: 0.9;
      transition: opacity .4s ease;
      pointer-events: none;
    }
    #hint.hidden { opacity: 0; }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="fit">Fit</button>
    <button id="real">100%</button>
    <small>Scroll to zoom, drag to move v1.1.1</small>
  </div>

  <div id="viewer">
    <img id="image" src="" alt="Image" draggable="false" ondragstart="return false;">
  </div>

  <script>
    const viewer = document.getElementById('viewer');
    const img    = document.getElementById('image');
    const fitBtn = document.getElementById('fit');
    const realBtn= document.getElementById('real');
    const hint   = document.getElementById('hint');

    // Берём ?url=...
    const params = new URLSearchParams(location.search);
    const url = params.get('url');
    if (url) img.src = url;

    // Состояние
    let scale = 1;
    let posX = 0, posY = 0;
    let isDrag = false, lastX = 0, lastY = 0;

    const MIN_SCALE = 0.05;
    const MAX_SCALE = 32;

    function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }

    function updateTransform(){
      img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
    }

    function centerAtCurrentScale(){
      const vw = viewer.clientWidth;
      const vh = viewer.clientHeight;
      const w = img.naturalWidth * scale;
      const h = img.naturalHeight * scale;
      posX = Math.floor((vw - w) / 2);
      posY = Math.floor((vh - h) / 2);
      updateTransform();
    }

    function fitToWindow(){
      const vw = viewer.clientWidth;
      const vh = viewer.clientHeight;
      const s = Math.min(vw / img.naturalWidth, vh / img.naturalHeight);
      scale = clamp(s, MIN_SCALE, MAX_SCALE);
      centerAtCurrentScale();
    }

    function set100(){
      scale = 1;
      centerAtCurrentScale();
    }

    // Зум вокруг курсора — корректная математика с origin = (0,0)
    viewer.addEventListener('wheel', (e) => {
      e.preventDefault(); // обязательно; passive:false по умолчанию тут
      const rect = viewer.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      // Координаты точки изображения под курсором ДО изменения
      const imgX = (mouseX - posX) / scale;
      const imgY = (mouseY - posY) / scale;

      // Плавный масштаб: экспонента лучше подходит и для тачпада
      const factor = Math.exp(-e.deltaY * 0.0015);
      const newScale = clamp(scale * factor, MIN_SCALE, MAX_SCALE);

      // Пересчитать смещение так, чтобы та же точка осталась под курсором
      posX = mouseX - imgX * newScale;
      posY = mouseY - imgY * newScale;
      scale = newScale;

      updateTransform();
      hideHintSoon();
    }, { passive: false });

    // Панорамирование ЛКМ
    viewer.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // только левая
      isDrag = true;
      lastX = e.clientX;
      lastY = e.clientY;
      viewer.style.cursor = 'grabbing';
      hideHintSoon();
    });
    window.addEventListener('mousemove', (e) => {
      if (!isDrag) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      posX += dx;
      posY += dy;
      lastX = e.clientX;
      lastY = e.clientY;
      updateTransform();
    });
    window.addEventListener('mouseup', () => {
      if (!isDrag) return;
      isDrag = false;
      viewer.style.cursor = 'grab';
    });

    // Кнопки
    fitBtn.addEventListener('click', fitToWindow);
    realBtn.addEventListener('click', set100);

    // Подсказка — погасить через пару секунд любой активности
    let hintTimer;
    function hideHintSoon() {
      clearTimeout(hintTimer);
      hintTimer = setTimeout(() => hint.classList.add('hidden'), 1200);
    }

    // Инициализация после загрузки изображения
    img.onload = () => {
      // стартуем с Fit
      fitToWindow();
      // лёгкий анти-рывок при первом показе
      requestAnimationFrame(() => updateTransform());
    };

    // На ресайз экрана — подогнать, если мы в «fit» (грубо считаем, что если картинка вмещается ровно, повторяем fit)
    window.addEventListener('resize', () => {
      // Опционально: всегда подгонять к окну
      fitToWindow();
    });
  </script>
</body>
</html>
